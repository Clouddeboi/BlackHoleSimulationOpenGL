#version 430

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D destTex;

//Camera uniform block (matches CameraUBO in C++)
layout(std140, binding = 0) uniform CameraBlock {
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
    vec4 camPos;
};

//Converts pixel coordinates to a ray in world space
vec3 generateRay(vec2 pixel, vec2 resolution) {
    //NDC coordinates [-1, 1]
    vec2 ndc = (pixel / resolution) * 2.0 - 1.0;

    //Clip space
    vec4 clip = vec4(ndc, -1.0, 1.0);

    //Eye space
    vec4 eye = invProj * clip;
    eye = vec4(eye.xy, -1.0, 0.0);

    //World space
    vec3 worldDir = normalize((invView * eye).xyz);
    return worldDir;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(destTex);

    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) return;

    vec2 resolution = vec2(imageSize);
    vec3 rayDir = generateRay(vec2(pixelCoords) + 0.5, resolution);
    vec3 rayOrigin = camPos.xyz;

    //--- Simple scene: infinite ground plane at y=0 ---
    vec3 color;

    if (rayDir.y < -0.001) {
        //intersect ground plane
        float t = -rayOrigin.y / rayDir.y;
        if (t > 0.0) {
            vec3 hitPos = rayOrigin + rayDir * t;
            //Checkerboard floor pattern
            float checker = mod(floor(hitPos.x) + floor(hitPos.z), 2.0);
            color = mix(vec3(0.8, 0.8, 0.8), vec3(0.1, 0.1, 0.1), checker);
        } else {
            color = vec3(0.5, 0.7, 1.0); //background sky
        }
    } else {
        //sky
        float t = 0.5 * (rayDir.y + 1.0);
        color = mix(vec3(0.7, 0.8, 1.0), vec3(0.2, 0.3, 0.5), t);
    }

    imageStore(destTex, pixelCoords, vec4(color, 1.0));
}
