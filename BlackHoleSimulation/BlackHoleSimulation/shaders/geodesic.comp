#version 430

layout(local_size_x = 8, local_size_y = 8) in;

layout(rgba32f, binding = 0) uniform image2D destTex;

layout(std140, binding = 0) uniform CameraBlock {
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
    vec4 camPos;
};

layout(std140, binding = 1) uniform BlackHoleBlock {
    vec3 bhPosition;
    float bhRadius;
};

layout(std140, binding = 2) uniform DiskBlock {
    float diskInnerRadius;
    float diskOuterRadius;
    vec3 diskColor;
};

layout(std140, binding = 3) uniform PlanetBlock {
    vec3 planetPosition;
    float planetRadius;
    vec3 planetColor;
    float _pad;
};

layout(std140, binding = 4) uniform TimeBlock {
    float uTime;
};

float hash(float n) {
    return fract(sin(n) * 43758.5453);
}

float noise(vec2 x) {
    vec2 p = floor(x);
    vec2 f = fract(x);
    f = f * f * (3.0 - 2.0 * f);
    float n = p.x + p.y * 57.0;
    return mix(
        mix(hash(n + 0.0), hash(n + 1.0), f.x),
        mix(hash(n + 57.0), hash(n + 58.0), f.x),
        f.y
    );
}

layout(binding = 5) uniform sampler2D uSmokeTex;

layout(binding = 6) uniform samplerCube uSkybox;

// Schwarzschild "acceleration" for photon (approximate, for visualization)
vec3 schwarzschildAccel(vec3 pos, float rs) {
    float r = length(pos);
    return -rs / (r * r) * normalize(pos);
}

// Runge-Kutta 4th order integration step for ray position and direction
void rk4Step(inout vec3 pos, inout vec3 dir, float stepSize, float rs) {
    vec3 k1_v = schwarzschildAccel(pos, rs);
    vec3 k1_x = dir;

    vec3 k2_v = schwarzschildAccel(pos + 0.5 * stepSize * k1_x, rs);
    vec3 k2_x = normalize(dir + 0.5 * stepSize * k1_v);

    vec3 k3_v = schwarzschildAccel(pos + 0.5 * stepSize * k2_x, rs);
    vec3 k3_x = normalize(dir + 0.5 * stepSize * k2_v);

    vec3 k4_v = schwarzschildAccel(pos + stepSize * k3_x, rs);
    vec3 k4_x = normalize(dir + stepSize * k3_v);

    dir = normalize(dir + (stepSize / 6.0) * (k1_v + 2.0 * k2_v + 2.0 * k3_v + k4_v));
    pos = pos + (stepSize / 6.0) * (k1_x + 2.0 * k2_x + 2.0 * k3_x + k4_x);
}

vec3 generateRay(vec2 pixel, vec2 resolution) {
    vec2 ndc = (pixel / resolution) * 2.0 - 1.0;
    vec4 clip = vec4(ndc, -1.0, 1.0);
    vec4 eye = invProj * clip;
    eye = vec4(eye.xy, -1.0, 0.0);
    return normalize((invView * eye).xyz);
}

vec3 innerColor = vec3(0.7, 0.85, 1.0);
vec3 outerColor = vec3(1.0, 0.4, 0.1);

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageSize = imageSize(destTex);

    if (pixelCoords.x >= imageSize.x || pixelCoords.y >= imageSize.y) return;

    vec2 resolution = vec2(imageSize);
    vec3 rayDir = generateRay(vec2(pixelCoords) + 0.5, resolution);
    vec3 rayOrigin = camPos.xyz;

    // Lensing integration parameters
    const int MAX_STEPS = 2000;
    const float STEP_SIZE = 0.1;

    vec3 pos = rayOrigin;
    vec3 dir = rayDir;
    vec3 color = vec3(0.0);
    bool hit = false;
    bool nearPhotonSphere = false;

    float photonSphereRadius = bhRadius * 1.5;
    float photonSphereThickness = bhRadius * 0.1;

    // Multiple disk images: accumulate color for each disk hit
    int diskHits = 0;
    vec3 diskAccum = vec3(0.0);

    for (int i = 0; i < MAX_STEPS; ++i) 
    {
        float r = length(pos);

        // Event horizon check
        if (r < bhRadius) {
            color = vec3(0.0);
            hit = true;
            break;
        }

        // Check if ray passes near the photon sphere at any step
        if (abs(r - photonSphereRadius) < photonSphereThickness) {
            nearPhotonSphere = true;
        }

        // Accretion disk intersection (XZ plane, y ~ 0)
        if (abs(pos.y) < STEP_SIZE) {
            float diskR = length(pos.xz);
            if (diskR > diskInnerRadius && diskR < diskOuterRadius) {
                // --- Relativistic Doppler and Beaming Effect ---
                vec3 diskTangent = normalize(vec3(-pos.z, 0.0, pos.x));
                float v = 0.75; // Fraction of c
                vec3 vDisk = v * diskTangent;
                vec3 photonDir = -normalize(dir);
                float beta = v;
                float cosTheta = dot(normalize(vDisk), photonDir);
                float gamma = 1.0 / sqrt(1.0 - beta * beta);
                float D = gamma * (1.0 - beta * cosTheta);

                // Disk local coordinates
                float phi = atan(pos.x, pos.z) + uTime * 1.0;
                float t = clamp((diskR - diskInnerRadius) / (diskOuterRadius - diskInnerRadius), 0.0, 1.0);

                // --- Tiling parameters ---
                const float tileCountU = 1.0; // Number of strips around the disk (angular)
                const float tileCountV = 1.0; // Number of tiles from inner to outer edge (radial)

                // --- Compute base tile coordinates ---
                float baseU = phi / (2.0 * 3.14159265); // [-0.5, 0.5]
                baseU = baseU - floor(baseU);           // [0,1)
                float baseV = t;                        // [0,1]

                // --- Which tile are we in? ---
                float tileIdxU = floor(baseU * tileCountU);
                float tileIdxV = floor(baseV * tileCountV);

                // --- Random offset for this tile (using hash) ---
                float tileRandU = hash(tileIdxU + tileIdxV * 100.0);
                float tileRandV = hash(tileIdxV + tileIdxU * 100.0);

                // --- Final tile-local coordinates, with random offset ---
                const float margin = 0.08;
                float texU = mix(margin, 1.0 - margin, baseU);
                float texV = mix(margin, 1.0 - margin, baseV);

                vec2 texCoords = vec2(texU, texV);

                // Sample the texture
                vec4 smokeSample = texture(uSmokeTex, texCoords);
                float smoke = smokeSample.a; // or .r for grayscale

                // Combine with procedural noise as before
                float combined = mix(noise(texCoords * 8.0 + uTime * 0.1), smoke, 0.95);

                // Height-based falloff for 3D "gas"
                float heightFalloff = exp(-abs(pos.y) * 2.0);

                //fade disk edges
                float edgeFade = smoothstep(diskInnerRadius, diskInnerRadius + 0.5, diskR) *
                                 (1.0 - smoothstep(diskOuterRadius - 0.5, diskOuterRadius, diskR));

                // Final color
                vec3 tempColor = mix(innerColor, outerColor, t);
                tempColor += 0.25 * combined;
                tempColor = clamp(tempColor, 0.0, 1.0);
                tempColor *= heightFalloff * edgeFade;

                vec3 baseColor = tempColor;

                vec3 dopplerColor = pow(baseColor, vec3(1.0/D, 1.0, D));
                vec3 diskCol = dopplerColor * (1.0 / D);

                // --- Gravitational Redshift ---
                float rs = bhRadius;
                float gRedshift = sqrt(1.0 - rs / diskR);
                diskCol = mix(vec3(diskCol.r, 0.0, 0.0), diskCol, gRedshift);

                // --- Lambertian Shading ---
                vec3 normal = vec3(0.0, 1.0, 0.0);
                vec3 lightDir = normalize(vec3(0.3, 1.0, 0.3)); // angled light
                float diffuse = max(dot(normal, lightDir), 0.0);

                // --- Black Hole Shadow on Disk (Analytical, limited to disk) ---
                vec3 shadowOrigin = pos + 0.01 * lightDir;
                vec3 oc = shadowOrigin - bhPosition;
                float b = dot(oc, lightDir);
                float c = dot(oc, oc) - bhRadius * bhRadius;
                float discriminant = b * b - c;
                bool inShadow = false;
                float maxShadowDistance = 30.0;
                if (discriminant > 0.0) {
                    float t = -b - sqrt(discriminant);
                    if (t > 0.0 && t < maxShadowDistance) {
                        vec3 shadowHit = shadowOrigin + t * lightDir;
                        float shadowDiskR = length(shadowHit.xz);
                        // Only shadow if intersection is within the disk region
                        if (abs(shadowHit.y) < STEP_SIZE &&
                            shadowDiskR > diskInnerRadius && shadowDiskR < diskOuterRadius) {
                            inShadow = true;
                        }
                    }
                }
                float shadowFactor = inShadow ? 0.05 : 1.0;

                // Escape condition (sky)
                if (r > 100.0) {
                    break;
                }

                // --- Specular Highlight ---
                vec3 viewDir = normalize(rayOrigin - pos);
                vec3 halfDir = normalize(lightDir + viewDir);
                float spec = pow(max(dot(normal, halfDir), 0.0), 32.0);
                spec = min(spec, 1.0);

                // --- Combine Shading ---
                diskCol *= (0.3 + 0.7 * diffuse) * shadowFactor;
                diskCol += vec3(1.0, 0.9, 0.7) * spec * 0.2 * shadowFactor;

                float emissionStrength = 0.5;
                vec3 emissionColor = diskColor * emissionStrength;
                diskCol += emissionColor;

                // --- Bloom Boost ---
                //diskCol *= 1.0;

                // Accumulate disk color, dimmer for higher-order images
                float weight = pow(0.5, float(diskHits));
                diskAccum += diskCol * weight;
                diskHits++;
            }      
        }
        // Sphere intersection
        float distToPlanet = length(pos - planetPosition);
        if (distToPlanet < planetRadius) {
            // Simple Lambertian shading for the planet sphere
            vec3 normal = normalize(pos - planetPosition);
            vec3 lightDir = normalize(vec3(0.3, 1.0, 0.3));
            float diffuse = max(dot(normal, lightDir), 0.0);
            vec3 planetCol = planetColor * (0.3 + 0.7 * diffuse);

            color = planetCol;
            hit = true;
            break;
        }

        // Escape condition (sky)
        if (r > 3000.0) {
            break;
        }

        rk4Step(pos, dir, STEP_SIZE, bhRadius);
    }

    if (diskHits > 0) {
        color = diskAccum;
        hit = true;
    }

        if (!hit) {
            vec3 lensedDir = normalize(dir); // after lensing integration
            vec3 skyColor = texture(uSkybox, lensedDir).rgb;

            //Apply gravitational redshift/time dilation
            float rEscape = length(pos);
            float rs = bhRadius;
            float gRedshift = sqrt(clamp(1.0 - rs / rEscape, 0.0, 1.0));
            skyColor = mix(vec3(skyColor.r, 0.0, 0.0), skyColor, gRedshift);

            color = skyColor;

            // --- Photon Sphere Highlight (only for escaping rays) ---
            if (nearPhotonSphere) {
                color = mix(color, vec3(5.0, 5.0, 1.5), 0.2);
            }
    }

    imageStore(destTex, pixelCoords, vec4(color, 1.0));
}